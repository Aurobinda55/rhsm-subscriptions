import groovy.json.JsonOutput

buildscript {
    // dependabot will parse dependencies.gradle by detecting the `apply from` below
    apply from: "dependencies.gradle"
}

plugins {
    id "swatch.spring-boot-conventions"
    id "org.sonarqube"
    id "net.researchgate.release"
    id 'com.adarshr.test-logger'
}

group = "org.candlepin"

release {
    // Use single quotes so the variables aren't interpreted in the build file itself!
    tagTemplate = '${name}-${version}'
    preTagCommitMessage = '[Subscriptions Release] - pre tag commit: '
    tagCommitMessage = '[Subscriptions Release] - creating tag: '
    newVersionCommitMessage = '[Subscriptions Release] - version bump: '
    pushReleaseVersionBranch = 'main'
    git {
        requireBranch = /develop|hotfix.*|release/
        pushToRemote = false
    }
}

dependencies {
    implementation project(':swatch-core')
    // Generates configuration metadata that IntelliJ can use
    annotationProcessor('org.hibernate:hibernate-jpamodelgen')
    compile project(":api")
    compile project(":clients:cloudigrade-client")
    compile project(":clients:insights-inventory-client")
    compile project(":clients:marketplace-client")
    compile project(":clients:product-client")
    compile project(":clients:prometheus-client")
    compile project(":clients:rbac-client")
    compile project(":clients:rhsm-client")
    compile project(":clients:subscription-client")
    compile project(":clients:user-client")
    compile project(":kafka-schema")

    compile("io.confluent:kafka-avro-serializer") {
        exclude group: "org.apache.kafka"
        // A transitive dependency, org.apache.zookeeper:zookeeper, includes log4j as well as slf4j.  We use
        // logback and SLF4J issues a warning if more than one logging implementation is on the classpath.
        // Frowny face to Zookeeper for adding a logging implementation to a library jar.
        exclude group: "org.slf4j", module: "slf4j-log4j12"
    }

    compile "org.springframework.boot:spring-boot-starter-data-jpa"
    compile "org.springframework.kafka:spring-kafka"
    // the following dep is necessary to avoid jackson kotlin warnings
    compile "com.fasterxml.jackson.module:jackson-module-kotlin"

    compile "org.liquibase:liquibase-core"
    compile "org.postgresql:postgresql"

    testCompile "org.springframework.security:spring-security-test"
    testCompile "org.springframework.kafka:spring-kafka-test"
    testCompile project(':swatch-core-test')

    runtime "org.hsqldb:hsqldb"
}

allprojects {
    // Add a custom task to output dependency info in a machine parseable format. Used to generate dependency
    // reports for Product Security.
    // adapted from https://stackoverflow.com/a/34641632
    // easiest to use via `./gradlew -q dependencyJson`
    tasks.register('dependencyJson') {
        doLast {
            def collectDeps = { ResolvedDependency dependency ->
                def collectedDeps = []
                // depth first traversal
                def dependencyStack = [dependency]
                while (!dependencyStack.isEmpty()) {
                    ResolvedDependency current = dependencyStack.pop()
                    collectedDeps.add(current)
                    current.children.forEach { dependencyStack.push(it) }
                }
                return collectedDeps
            }
            Set allDeps = []
            def projects = allprojects
                    .grep { project -> !project.name.endsWith("-test") }
                    .grep { project -> 'default' in project.configurations.names }
            for (Project project : projects) {
                // see https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management
                // "default" is all artifacts required at runtime
                for (ResolvedDependency topLevelDependency : project.configurations.default.resolvedConfiguration.firstLevelModuleDependencies) {
                    def collectedDeps = collectDeps(topLevelDependency)
                    for (ResolvedDependency dependency : collectedDeps) {
                        // skip deps that appear to be from this project
                        if (dependency.moduleGroup != project.group || dependency.moduleVersion != project.version) {
                            allDeps.add([
                                    group  : dependency.moduleGroup,
                                    name   : dependency.moduleName,
                                    version: dependency.moduleVersion,
                            ])
                        }
                    }

                }
            }
            println JsonOutput.toJson(allDeps.sort { "${it.group}:${it.name}:${it.version}" })
        }
    }
}


compileJava.dependsOn(processResources)
project.tasks["sonarqube"].dependsOn "test"
project.tasks["sonarqube"].dependsOn "jacocoTestReport"

project(":api") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "org.openapi.generator"

    ext {
        api_spec_path = "${projectDir}/rhsm-subscriptions-api-spec.yaml"
        config_file = "${projectDir}/rhsm-subscriptions-api-config.json"
    }

    openApiGenerate {
      generatorName = "jaxrs-spec"
      inputSpec = api_spec_path
      configFile = config_file
      outputDir = "$buildDir/generated"
      configOptions = [
          interfaceOnly: "true",
          generatePom: "false",
          dateLibrary: "java8",
      ]
    }

    openApiValidate {
        inputSpec = api_spec_path
    }

    task generateApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = api_spec_path
        outputDir = "$buildDir/generated/openapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    processResources {
        from "$buildDir/generated/openapijson/openapi.json"
        from api_spec_path
        rename { String fileName ->
            api_spec_path.endsWith(fileName) ? 'openapi.yaml' : fileName  // rename yaml to openapi.yaml
        }
    }

    dependencies {
        implementation "javax.annotation:javax.annotation-api"
        compile "com.fasterxml.jackson.core:jackson-annotations"
        compile "javax.validation:validation-api"
        compile "org.jboss.spec.javax.ws.rs:jboss-jaxrs-api_2.1_spec"
        compile "io.swagger:swagger-annotations"
        compile "com.google.code.findbugs:jsr305:3.0.2"
        compile "org.openapitools:jackson-databind-nullable:0.2.2"
    }

    sourceSets.main.java.srcDirs = ["${buildDir}/generated/src/gen/java"]
    compileJava.dependsOn tasks.openApiGenerate
    processResources.dependsOn tasks.generateOpenApiJson
}

project(":kafka-schema") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "com.commercehub.gradle.plugin.avro-base"

    dependencies {
        compile "org.apache.avro:avro"
    }

    task generateAvro(type: com.commercehub.gradle.plugin.avro.GenerateAvroJavaTask) {
        // sub dir needed so that the plugin does not traverse into the build dir (if it exists).
        source("${projectDir}/avro")
        outputDir = file("${buildDir}/generated/avro/src/main/java")
    }

    sourceSets.main.java.srcDirs += "${buildDir}/generated/avro/src/main/java"
    compileJava.source(generateAvro.outputs)
    compileJava.dependsOn tasks.generateAvro
}
