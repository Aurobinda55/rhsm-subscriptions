import groovy.json.JsonOutput

buildscript {
    // dependabot will parse dependencies.gradle by detecting the `apply from` below
    apply from: "dependencies.gradle"
}

plugins {
    id "swatch.spring-boot-conventions"
    id "org.sonarqube"
    id "nebula.release"
    id 'com.adarshr.test-logger'
    id 'jacoco'
    id "org.openapi.generator"
}

group = "org.candlepin"

dependencies {
    implementation project(':swatch-core')
    implementation project(":api")
    implementation project(":clients:cloudigrade-client")
    implementation project(":clients:cloudigrade-internal-client")
    implementation project(":clients:insights-inventory-client")
    implementation project(":clients:rh-marketplace-client")
    implementation project(":clients:product-client")
    implementation project(":clients:prometheus-client")
    implementation project(":clients:rbac-client")
    implementation project(":clients:rhsm-client")
    implementation project(":clients:subscription-client")
    implementation project(":clients:user-client")
    implementation project(":kafka-schema")

    implementation("io.confluent:kafka-avro-serializer") {
        exclude group: "org.apache.kafka"
        // A transitive dependency, org.apache.zookeeper:zookeeper, includes log4j as well as slf4j.  We use
        // logback and SLF4J issues a warning if more than one logging implementation is on the classpath.
        // Frowny face to Zookeeper for adding a logging implementation to a library jar.
        exclude group: "org.slf4j", module: "slf4j-log4j12"
    }

    implementation "org.springframework.boot:spring-boot-starter-data-jpa"
    implementation "org.springframework.kafka:spring-kafka"
    // the following dep is necessary to avoid jackson kotlin warnings
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin"

    implementation "org.liquibase:liquibase-core"
    implementation "org.postgresql:postgresql"

    testImplementation "org.springframework.security:spring-security-test"
    testImplementation "org.springframework.kafka:spring-kafka-test"
    testImplementation project(':swatch-core-test')

    runtimeOnly "org.hsqldb:hsqldb"
}

allprojects {
    // Add a custom task to output dependency info in a machine parseable format. Used to generate dependency
    // reports for Product Security.
    // adapted from https://stackoverflow.com/a/34641632
    // easiest to use via `./gradlew -q dependencyJson`
    tasks.register('dependencyJson') {
        doLast {
            def collectDeps = { ResolvedDependency dependency ->
                def collectedDeps = []
                // depth first traversal
                def dependencyStack = [dependency]
                while (!dependencyStack.isEmpty()) {
                    ResolvedDependency current = dependencyStack.pop()
                    collectedDeps.add(current)
                    current.children.forEach { dependencyStack.push(it) }
                }
                return collectedDeps
            }
            Set allDeps = []
            def projects = allprojects
                    .grep { project -> !project.name.endsWith("-test") }
                    .grep { project -> 'default' in project.configurations.names }
            for (Project project : projects) {
                // see https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management
                // "default" is all artifacts required at runtime
                for (ResolvedDependency topLevelDependency : project.configurations.default.resolvedConfiguration.firstLevelModuleDependencies) {
                    def collectedDeps = collectDeps(topLevelDependency)
                    for (ResolvedDependency dependency : collectedDeps) {
                        // skip deps that appear to be from this project
                        if (dependency.moduleGroup != project.group || dependency.moduleVersion != project.version) {
                            allDeps.add([
                                    group  : dependency.moduleGroup,
                                    name   : dependency.moduleName,
                                    version: dependency.moduleVersion,
                            ])
                        }
                    }

                }
            }
            println JsonOutput.toJson(allDeps.sort { "${it.group}:${it.name}:${it.version}" })
        }
    }
}

jacocoTestReport {
    reports {
        xml.required = true
    }
}

compileJava.dependsOn(processResources)
project.tasks["sonarqube"].dependsOn "test"
project.tasks["sonarqube"].dependsOn "jacocoTestReport"

/* TODO - The directives below to generate the API classes are duplicates of the
 * the directives we use for the api module.  We need to DRY this up but that is
 * going to require a little Gradle-fu that I don't currently possess.
 */
ext {
    api_spec_path = "${projectDir}/src/main/spec/internal-tally-api.yaml"
}

openApiGenerate {
    generatorName = "jaxrs-spec"
    inputSpec = api_spec_path
    outputDir = "$buildDir/generated"
    apiPackage = "org.candlepin.subscriptions.tally.admin.api"
    modelPackage = "org.candlepin.subscriptions.tally.admin.api.model"
    invokerPackage = "org.candlepin.subscriptions.tally.admin"
    groupId = "org.candlepin"
    configOptions = [
            interfaceOnly: "true",
            generatePom: "false",
            dateLibrary: "java8",
    ]
}

openApiValidate {
    inputSpec = api_spec_path
}

task generateApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
    generatorName = "html"
    inputSpec = api_spec_path
    outputDir = "$buildDir/docs"
    generateApiDocumentation = true
    generateModelDocumentation = true
    generateModelTests = false
    generateApiTests = false
    withXml = false
}

task generateOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
    generatorName = "openapi"
    inputSpec = api_spec_path
    outputDir = "$buildDir/generated/openapijson"
    generateApiDocumentation = true
    generateModelDocumentation = true
    generateModelTests = false
    generateApiTests = false
    withXml = false
}

processResources {
    from "$buildDir/generated/openapijson/openapi.json"
    from api_spec_path
    rename { String fileName ->
        api_spec_path.endsWith(fileName) ? 'openapi.yaml' : fileName  // rename yaml to openapi.yaml
    }
}

sourceSets.main.java.srcDirs += ["${buildDir}/generated/src/gen/java"]
compileJava.dependsOn tasks.openApiGenerate
processResources.dependsOn tasks.generateOpenApiJson
processResources.dependsOn tasks.openApiGenerate

project(":api") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "org.openapi.generator"

    ext {
        api_spec_path = "${projectDir}/rhsm-subscriptions-api-spec.yaml"
        internal_sub_sync_api_spec_path = "${projectDir}/internal-subscriptions-sync-api-spec.yaml"
        config_file = "${projectDir}/rhsm-subscriptions-api-config.json"
    }

    openApiGenerate {
        generatorName = "jaxrs-spec"
        inputSpec = api_spec_path
        configFile = config_file
        outputDir = "$buildDir/generated"
        configOptions = [
                interfaceOnly: "true",
                generatePom: "false",
                dateLibrary: "java8",
        ]
    }

    task generateInternalSubSyncApi(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "jaxrs-spec"
        inputSpec = internal_sub_sync_api_spec_path
        configFile = config_file
        outputDir = "$buildDir/generated"
        configOptions = [
                interfaceOnly: "true",
                generatePom: "false",
                dateLibrary: "java8",
                useTags: "true"
        ]
    }

    task validateApiSpec(type: org.openapitools.generator.gradle.plugin.tasks.ValidateTask){
        inputSpec = api_spec_path
    }

    task validateInternalSubSyncApiSpec(type: org.openapitools.generator.gradle.plugin.tasks.ValidateTask){
        inputSpec = internal_sub_sync_api_spec_path
    }

    task validateSpecs(dependsOn: ['validateApiSpec', 'validateInternalApiSpec'])

    task generateApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = api_spec_path
        outputDir = "$buildDir/generated/openapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateInternalSubSyncApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = internal_sub_sync_api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateInternalSubSyncOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = internal_sub_sync_api_spec_path
        outputDir = "$buildDir/generated/internalopenapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    processResources {
        with copySpec {
            from "$buildDir/generated/openapijson/openapi.json"
            from api_spec_path
            rename { String fileName ->
                api_spec_path.endsWith(fileName) ? 'openapi.yaml' : fileName  // rename yaml to openapi.yaml
            }
        }
        with copySpec {
            //TODO: this makes gradle complain about duplicate files even with the rename. Need to look into fix
//            from "$buildDir/generated/internalopenapijson/openapi.json"
//            rename { String fileName -> 'internalsubsyncopenapi.yaml' // rename yaml to internalsubsyncopenapi.yaml
//            }
            from internal_sub_sync_api_spec_path
            rename { String fileName ->
                internal_sub_sync_api_spec_path.endsWith(fileName) ? 'internalsubsyncopenapi.yaml' : fileName  // rename yaml to internalopenapi.yaml
            }
        }
    }

    dependencies {
        implementation "javax.annotation:javax.annotation-api"
        implementation "com.fasterxml.jackson.core:jackson-annotations"
        implementation "javax.validation:validation-api"
        implementation "org.jboss.spec.javax.ws.rs:jboss-jaxrs-api_2.1_spec"
        implementation "io.swagger:swagger-annotations"
        implementation libraries["jsr305"]
        implementation libraries["jackson-databind-nullable"]
    }

    sourceSets.main.java.srcDirs += ["${buildDir}/generated/src/gen/java"]
    compileJava.dependsOn tasks.openApiGenerate
    compileJava.dependsOn tasks.generateInternalSubSyncApi
    processResources.dependsOn tasks.generateInternalSubSyncApi
    processResources.dependsOn tasks.openApiGenerate
    processResources.dependsOn tasks.generateOpenApiJson
    processResources.dependsOn tasks.generateInternalSubSyncOpenApiJson


}

project(":kafka-schema") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "com.github.davidmc24.gradle.plugin.avro"

    dependencies {
        implementation "org.apache.avro:avro"
    }

    task generateAvro(type: com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask) {
        // sub dir needed so that the plugin does not traverse into the build dir (if it exists).
        source("${projectDir}/avro")
        outputDir = file("${buildDir}/generated/avro/src/main/java")
    }

    sourceSets.main.java.srcDirs += "${buildDir}/generated/avro/src/main/java"
    compileJava.source(generateAvro.outputs)
    compileJava.dependsOn tasks.generateAvro
}
