#! /usr/bin/env python3

import argparse
import logging
import os
import shutil
import sys

from rhsm_subscriptions import handlers

logging.basicConfig()
log = logging.getLogger("deploy-insights")


class InventoryHandler(handlers.ActionHandler):
    INSIGHTS_CHECKOUT_DIR = "insights-host-inventory"
    INSIGHTS_PROMETHEUS_DIR = "prometheumultiprocess"

    def __init__(self, args):
        self.args = args

    def verify_pipenv(self):
        pipenv = shutil.which("pipenv")
        if not pipenv:
            raise RuntimeError("Please install pipenv")

    def run(self, *args, **kwargs):
        try:
            os.mkdir(self.INSIGHTS_PROMETHEUS_DIR)
        except FileExistsError as e:
            log.info("Skipping creation of %s", self.INSIGHTS_PROMETHEUS_DIR)

        try:
            os.chdir(self.INSIGHTS_CHECKOUT_DIR)
        except FileNotFoundError as e:
            raise RuntimeError(
                "No directory found for insights-host-inventory. Make sure the submodule init succeeded"
            ) from e

        os.environ["INVENTORY_DB_NAME"] = self.args.insights_db_name
        os.environ["LISTEN_PORT"] = self.args.insights_port
        os.environ["INVENTORY_LOGGING_CONFIG_FILE"] = "logconfig.ini"
        os.environ["INVENTORY_SHARED_SECRET"] = self.args.insights_secret
        os.environ["FLASK_DEBUG"] = "1"
        os.environ["prometheus_multiproc_dir"] = os.path.join("..", self.INSIGHTS_PROMETHEUS_DIR)

        self.verify_pipenv()

        # TODO pipenv install every time is slow and not necessary. Need to find a way to verify if the
        #  virtualenv has been inited or not
        self.shell_cmd("pipenv install --dev")
        self.shell_cmd("pipenv run python manage.py db upgrade")

        # Exec the pipenv command to run the insights flask application.  The current process is replaced.
        # We use the "execlpe" variant since we have a) fixed arguments b) want to use the PATH and c) want
        # to pass in our altered environment.
        log.info("Invoking insights Flask application")
        os.execlpe("pipenv", "pipenv", "run", "python", "run.py", os.environ)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Deploy rhsm-conduit")
    parser.add_argument("--insights-db-password", help="Database password")
    parser.add_argument("--insights-db-host", default="localhost", help="Database host")
    parser.add_argument("--insights-db-user", default="insights", help="Name of the insights DB user")
    parser.add_argument("--insights-db-name", default="inventory", help="Name of the insights DB")
    parser.add_argument("--insights-secret", default="mysecret", help="Secret for the insights app")
    # TODO add a check to make sure the value is an integer.  It needs to be passed to os.environ as a
    #  string, but we should make sure it can be cast to an int
    parser.add_argument("--insights-port", default="8080", help="Port to run the insights app on")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose mode")
    parsed_args = parser.parse_args()

    if parsed_args.verbose:
        log.setLevel(logging.DEBUG)
        # Only print stack traces in debug mode
        err_log_func = log.exception
    else:
        log.setLevel(logging.INFO)
        err_log_func = log.error

    rc = 0
    try:
        submodule_handler = handlers.SubmoduleHandler()
        submodule_handler.run()

        db_handler = handlers.PostgresDbHandler(
            db_name=parsed_args.insights_db_name,
            db_host=parsed_args.insights_db_host,
            db_user=parsed_args.insights_db_user,
            db_password=parsed_args.insights_db_password
        )
        db_handler.run()

        inventory_handler = InventoryHandler(parsed_args)
        inventory_handler.run()
    except KeyboardInterrupt:
        rc = 1
        log.info("User interrupted execution")
    except RuntimeError as e:
        rc = 1
        err_log_func(str(e))
    except Exception as e:
        log.exception("Unknown error")
    finally:
        sys.exit(rc)

